### [CSS field-sizing属性简介](https://www.zhangxinxu.com/wordpress/2025/10/css-field-sizing/)

```css
/* 无论是单行输入框，还是多行文本域，其宽度在内容输入的时候，都是固定的，如果希望尺寸跟着内容的宽度走 */
input {
    field-sizing: content
}
```

### 指数退避算法

### [Python项目管理神器 PDM，用它管理项目爽到飞起！](https://juejin.cn/post/7503596255122161690)

### [JavaScript Set有新功能啦，子、交、并、补轻松搞定](https://juejin.cn/post/7411416025729957928)

```
子，isSubsetOf/isSupersetOf/isDisjointFrom
交，intersection
并，union
补，difference/symmetricDifference
```

### [写给自己看的display: grid布局教程](https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/?shrink=1)

> 1fr

### [泄露记录](https://databreach.com/)

### [Magentic-UI](https://github.com/microsoft/magentic-ui)

> Magentic-UI 是一个以人为中心的 AI 代理研究原型，可解决复杂的网络和编码任务，这些任务可能需要监控。与其他黑盒代理不同，该系统在执行前会揭示其计划，允许你指导其操作，并在浏览网站、执行代码和分析文件时请求对敏感操作的批准。查看演示部分，了解你可以完成哪些任务。

### playwright

> Playwright 是一个用于自动化浏览器操作的强大工具，支持多种浏览器（如 Chrome、Firefox、Safari）和平台（如 Windows、macOS、Linux）。它提供了丰富的 API 来模拟用户交互、导航网页、提取数据等。Playwright 以其稳定性、跨平台兼容性和强大的功能而闻名，成为了自动化测试和浏览器操作的首选工具。

### [处理element ui table组件加了 show-overflow-tooltip 后, 悬浮无法复制问题](https://juejin.cn/post/7329194915683729446)

> 二次开发组件写法借鉴

### [C V大法：让你用最简单的方式使用Vue2 + Web Worker + js-xlsx 解析excel数据](https://juejin.cn/post/7010046891480055815)

> Web Worker

### [监听浏览器页面切换/刷新/关闭事件](https://www.jianshu.com/p/bc5d242aff09)

> visibilitychange

### [SingleFile](https://github.com/gildas-lormeau/SingleFile)

> SingleFile 是一个兼容 Chrome、Firefox（桌面版和移动版）、Microsoft Edge、Safari、Vivaldi、Brave、Waterfox、Yandex 浏览器和 Opera 的网络扩展（以及一个命令行工具）。

### [矩阵乘法](http://matrixmultiplication.xyz/)

### [CSS reading-flow和reading-order属性简介](https://www.zhangxinxu.com/wordpress/2025/10/css-reading-flow-order/)

> reading-flow reading-order

### [模块的特殊变量](https://langshift.dev/zh-cn/docs/js2py/module-02-module-system#23-%E6%A8%A1%E5%9D%97%E7%9A%84%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F)

### [动态导入](https://langshift.dev/zh-cn/docs/js2py/module-02-module-system#62-%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5)

### [特殊方法魔术方法](https://langshift.dev/zh-cn/docs/js2py/module-03-oop-functional#24-%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95)

### [列表推导式](https://langshift.dev/zh-cn/docs/js2py/module-03-oop-functional#33-%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F)

### [Canvas也支持锥形渐变了createConicGradient方法](https://www.zhangxinxu.com/wordpress/2025/10/js-canvas-createconicgradient/?shrink=1)

```js
const canvas = document.querySelector("canvas");
const ctx = canvas.getContext("2d");

// 尺寸
const size = 300;
canvas.width = size;
canvas.height = size;

// 创建锥形渐变
const gradient = ctx.createConicGradient(-0.5 * Math.PI, size / 2, size / 2);

// 色带颜色
const arrColor = ['#10239E', '#2F54EB', '#597EF7', '#85A5FF', '#D6E4FF'];
// 各自占据的百分比
const arrPercent = [0.07, 0.13, 0.2, 0.27, 0.33];

// 添加中断点
let sumPercent = 0;
arrPercent.forEach((percent, index) => {
    gradient.addColorStop(sumPercent, arrColor[index]);
    sumPercent += percent;
    gradient.addColorStop(sumPercent, arrColor[index]);
});

// 设置渐变为填充样式
ctx.fillStyle = gradient;
// 绘制圆形
ctx.ellipse(size / 2, size / 2, size / 2 - 30, size / 2 - 30, 0, 0, 2 * Math.PI);
// 填充
ctx.fill();
```

### [CanvasRenderingContext2D：ellipse() 方法](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/ellipse)

```js
ctx.ellipse(100, 100, 50, 75, Math.PI / 4, 0, 2 * Math.PI);
```

### [全球儿歌乐园](https://beddysongs.com/zh)

### [elementUI 表格宽度自适应、不换行](https://www.jianshu.com/p/8b7ea304dc54)

> context.measureText方法可以测量文本的宽度

### 计算文本宽度

```js
/**
 * 计算文本宽度（包含可选内边距）
 * @param {Object} options - 配置对象
 * @param {string} options.str - 要测量的文本内容
 * @param {string} [options.style='12px PingFang HK'] - 文本样式
 * @param {number} [options.padding=0] - 额外内边距
 * @returns {number} 文本宽度（像素值）
 */
export const textWidth = ({
    str,
    style = '12px PingFang HK',
    padding = 0
}) => {

    // 创建临时canvas用于测量文本宽度
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    if (!context) {
        console.warn('Canvas上下文获取失败');
        return 0;
    }

    // 设置字体样式并测量文本宽度
    context.font = style;
    const textWidth = context.measureText(str).width;

    return textWidth + Number(padding);

};
```
